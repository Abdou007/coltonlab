#summary How we plan to implement the object-oriented design pattern with our LabVIEW software.
#labels Phase-Design,Featured

= Introduction =

Currently our lab uses a monolithic design pattern.  This is bloated, complex, duplicates effort, and is ridiculously hard to maintain.  As it currently stands, no single human can comprehend let alone maintain our codebase.  Splitting up the code into bite-sized chunks makes it possible (and easy) to use and maintain.  

The benefits of object oriented design are overwhelming.  Newbies can get up and running quickly.  The design is much simpler.  Duplicated code is removed, and I would bet the size of the source tree would easily shrink to half.  New features need to be added only once, and bugfixes are localized and easy to change.  Write once, read many.  If planned appropriately, new code can fit right in with minimal and only localized changes to implement them.

The disadvantage is that the learning curve goes up.  Newbies must put in the time to learn what object-oriented design is and does.  However, learning OO is a good investment.  As we are students, we'll graduate someday and go where these skills will be widely applicable.  Spending endless hours poring over a monolithic code tree is counterproductive and doesn't teach anything but patience.

= Implementation Plan =
  # Pore over existing drivers and scanners.  Make featurelist of needed things.  Throw out unnecessary features and kill bloat.
  # Spring cleaning.  Find and delete all ancient, unneeded programs.
  # Design the interface hierarchy.  Make sure they meet needs.  "The best opportunity to improve the program is designing the interfaces effectively." (or something like that.)
  # Design and Document all the function prototypes we think we'll need.
  # Implement the class hierarchy over the existing drivers.
  # Reimplement the static control panels with the driver interfaces.
  # Implement a ReadableInterface driver.  This is equivalent to our Etch-A-Sketch, except it will be unified, generic to work with any instrument.  This will be the first working prototype.
  # Implement a ScannableInterface driver.
  # Figure out how to do data processing and driver state serialization.
  # Implement a ScanAndRead driver.  This will be the master scan control program.
  # Implement a ScanAndReadMulti driver that can do more than one each of Scannable and Readable.

= Scan Control Program =
  # Factory - instantiate default instruments, or deserialize a saved scan configuration.
  # Scan Setup - user configures instrument settings for Scannable and Readable instruments (perhaps more than one).  Output datafile name and lab comments box.
  # Scan, abort button, check error conditions or emergent events
  # Generate waveform datatype - need to figger out how to do multiple datatypes in one (e.g. Volts, Teslas, etc. all on same graph)  What kind of data structure?  Waveform datatype?
  # Data preprocessing - (average, normalize, etc.) before sent to graph on screen
  # Graph and write data to disk
  # Serialize/marshal instrument objects INSIDE DATAFILE.  This will make VERIFIABLE, REPEATABLE scan results since instrument configuration is "guaranteed"

= Abstraction levels =
  # Main control
  # Scan programs
  # ScanType scanners
  # Object-oriented instrument drivers
  # Static atomic instrument drivers
  # VISA, other low-level voodoo
  # Hardware

Note each instrument needs TWO sets of drivers:
-Static: atomic VISA commands.  These perform one task, do it well, and store no state.
-Class-based: larger molecular instrument tasks, i.e. set up for scan, that can be handled in a generic way.  Ideally, scan programs should call the class-based drivers, which call the deeper atomic VISA commands.

= class Instrument =
implements Serializable
Members: NO TYPE PUNNING allowed.  (Eg. combine frequency and period into just one value.)  One variable which is interpreted by accessors and mutators accordingly. 
  * Instrument(Visa v) : lock
  * ~Instrument() : unlock v
  * static showSettingsPanel()
  * InstrSet readSettings()
     

  * void writeSettings(InstrSet)
  * void resetDefault()

== interface Serializable ==
  * serialize() - xml? binary?
  * deserialize() - called from factory?


== class Collection: public Instrument ==
Accessor wrapper functions for an array of Instruments.
  * InstrSet readSettings()
     -inheritance-based replacement for Current Instr/Read Instr Settings.vi

== interface Scannable: public Instrument ==
extends Instrument, implements Iterator
Scannable Instruments are the independent variables during a typical scan.
  * setMin(), setMax(), setStepSize()
  * scanSetUp()
    * instr-specific scan setup,  just like Scan Set Up/Scan Setup - Pulse Generator.vi.  Checks if instr is on and confirms settings, e.g. "Are you sure you want to set the outputs to 3000 volts?"
    * ScanType::setupInstrs() calls each of these functions for instrument-specific setup.
  * reset() - debounce code
  * serialize - all?
  * throw exception on error / emergent conditions
  * scanNextStep() - move to next position
=== class Spectrometer: public Scannable ===
=== class MagnetField: public Scannable ===
=== class Microwave: public Readable ===

== interface Readable: public Instrument ==
extends Instrument
Readable Instruments are the dependent variables on a typical scan.
  * _read() - read data point, timestamp, waveform point
  * _readWaveform() - get the historical waveform since init
  * Are waveforms even appropriate?
  * how do units unify into one data structure?
  * throw exceptions?

=== class DAQMX Analog: public Readable ===
=== class Lockin SR80: public Readable ===
=== class Photon Counter: public Readable ===
=== class MagnetTemp: public Readable ===



= Open Issues about this Plan =
  # Exception handling
  # Unify waveform datatypes
  # Emergency stop / keep instruments from blowing up the lab
  # Implement structs, convert to typedefs, convert to classes
  # *LabView doesn't have multiple inheritance.  Oops.*
  # *Labview doesn't allow mutating objects on-heap.  There are no pointers, ever.  Everything is passed in and out by reference. _This could be a deal breaker._*
  # Min version LabView 8.2, august 2006